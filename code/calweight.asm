.MODEL SMALL
.386
.STACK 100
.DATA
	
	MSG1 DB "TYPES OF PORK$"
	ASTERISK DB "*************$"
	MSG2 DB "Enter a number (1 to 6): $"
	ERRORM DB "Invalid! Please enter again: $"
	MSG3 DB "Enter the weight (1kg,3kg or 5kg): $"
	MSG4 DB "Enter the quantity: $"
	MSG5 DB "The total weight of $"
	KG DB ".00 kg$"
	NL DB 0AH,0DH,"$"

	BELLY DB "1. PORK BELLY$"
	LOIN DB "2. PORK LOIN$"
	RIB DB "3. PORK RIB$"
	SHOULDER DB "4. PORK SHOULDER$"
	HAM DB "5. HAM$"
	QUIT DB "6. QUIT$"
	
	WEIGHT DB ?
	CHOICE DB ?

	TYPE1M DB "Pork Belly is $"
	TYPE2M DB "Pork Loin is $"
	TYPE3M DB "Pork Rib is $"
	TYPE4M DB "Pork Shoulder is $"
	TYPE5M DB "Ham is $"

	INPUT DB 30 DUP ('$')
	N      DW ?
	COUNT  DW ?
	OUTPUT DB 30 DUP ('$')

.CODE
MAIN PROC

	MOV AX,@DATA
	MOV DS,AX

	;-----DISPLAY THE MENU
	MOV AH,09H
	LEA DX,MSG1
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,ASTERISK
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H
	
	MOV AH,09H
	LEA DX,BELLY
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,LOIN
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,RIB
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,SHOULDER
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,HAM
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,QUIT
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	MOV AH,09H
	LEA DX,NL
	INT 21H

	;-----DISPLAY THE INPUT MESSAGE
	MOV AH,09H	
	LEA DX,MSG2
	INT 21H
		
	;-----ALLOW USER TO SELECT THE TYPE OF MEAT
	SELECTION:
		MOV AH,01H
		INT 21H
		MOV CHOICE,AL
		
		MOV AH,09H
		LEA DX,NL
		INT 21H		
		
		CMP AL,"1"
		JNGE ERROR

		CMP AL,"6"
		JNLE ERROR

		JMP VALID

		ERROR:
			MOV AH,09H
			LEA DX,ERRORM
			INT 21H

	JMP SELECTION

	;-----ALLOW USER TO ENTER THE WEIGHT OF MEAT
	VALID:			
		MOV AH,09H
		LEA DX,MSG3		;ENTER THE WEIGHT (1,3,5KG) :
		INT 21H

	CONTINUE:
		MOV AH,01H
		INT 21H
		SUB AL,30H
		MOV WEIGHT,AL

		MOV AH,09H
		LEA DX,NL
		INT 21H

		CMP AL,1		;COMPARE THE INPUT WITH NUMBER 1
		JE CORRECT
		
		CMP AL,3		;COMPARE THE INPUT WITH NUMBER 3
		JE CORRECT

		CMP AL,5		;COMPARE THE INPUT WITH NUMBER 5
		JE CORRECT

		MOV AH,09H
		LEA DX,ERRORM
		INT 21H

	JMP CONTINUE








	CORRECT:
		MOV AH,09H
		LEA DX,MSG4
		INT 21H	
	
	;CAPTURE NUMBER CHAR BY CHAR. NOTICE CHR(13) WILL BE
	;STORED IN STRING AND COUNTED.
    MOV BX , OFFSET INPUT
    MOV COUNT , 0

	L1:
		MOV AH , 1    
		INT 21H               ;CAPTURE ONE CHAR FROM KEYBOARD.
		MOV [BX] , AL         ;STORE CHAR IN STRING.
		INC BX 
		INC COUNT
		CMP AL , 0DH
		JNE L1                ;IF CHAR IS NOT "ENTER", REPEAT.           

		DEC COUNT             ;NECESSARY BECAUSE CHR(13) WAS COUNTED.


	;CONVERT STRING TO NUMBER. 
		MOV BX , OFFSET INPUT ;BX POINTS TO THE FIRST CHAR.
		ADD BX,  COUNT        ;NOW BX POINTS ONE CHAR AFTER THE LAST ONE.
		MOV BP, 0             ;BP WILL BE THE NUMBER CONVERTED FROM STRING.
		MOV CX, 0             ;PROCESS STARTS WITH 10^0.
	
	L2:      
	;GET CURRENT POWER OF 10.
		CMP CX, 0
		JE  FIRST_TIME        ;FIRST TIME IS 1, BECAUSE 10^0 = 1.
		MOV AX, 10
		MUL CX                ;CX * 10. NEXT TIME=100, NEXT TIME=1000...
		MOV CX, AX            ;CX == 10^CX.
		JMP L22               ;SKIP THE "FIRST TIME" BLOCK.

	FIRST_TIME:    
		MOV CX, 1             ;FIRST TIME 10^0 = 1.

	L22:    
	;CONVERT CURRENT CHAR TO NUMBER.   
		DEC BX                ;BX POINTS TO CURRENT CHAR.
		MOV AL , [BX]         ;AL = CURRENT CHAR.
		SUB AL , 30H 
		MUL WEIGHT
    
    
				 ;CONVERT CHAR TO NUMBER.
	;MULTIPLY CURRENT NUMBER BY CURRENT POWER OF 10.
		MOV AH, 0             ;CLEAR AH TO USE AX.
		MUL CX                ;AX * CX = DX:AX. LET'S IGNORE DX.
		ADD BP , AX           ;STORE RESULT IN BP.    

	;CHECK IF THERE ARE MORE CHARS.    
		DEC COUNT
		CMP COUNT , 0
		JNE L2


	;EXTRACT DIGITS FROM NUMBER ONE BY ONE BY DIVIDING THEM BY 10 AND
	;STORING THE REMAINDERS INTO STACK. WE USE THE STACK BECAUSE THE
	;STACK STORES DATA IN REVERSE ORDER.
		MOV COUNT, 0
		MOV AX, BP            ;AX = NUMBER TO PROCESS.

	L3:
		MOV DX, 0             ;CLEAR DX. NECESSARY FOR DIV.
		MOV CX, 10            ;WILL DIVIDE BY 10.    
		DIV CX                ;DX:AX / 10. RESULT: AX=QUOTIENT, DX=REMAINDER.    
		ADD DL,30H             ;CONVERT DIGIT TO CHAR.
		PUSH DX               ;STORE DIGIT IN STACK.
		INC COUNT
		CMP AX, 0             
		JNE L3                ;IF QUOTIENT != 0, REPEAT.


	;EXTRACT CHARS FROM STACK IN REVERSE ORDER TO BUILD THE NUMBER IN STRING.
		MOV BX, OFFSET OUTPUT
	L4:
		POP DX                ;RETRIEVE ONE CHAR.
		MOV [BX], DL          ;STORE CHAR IN STRING.
		INC BX                ;POSITION FOR NEXT CHAR.
		DEC COUNT
		JNZ L4                ;IF ( COUNT != 0 ) REPEAT.    


	;DISPLAY MESSAGE.
		MOV AH,09H
		LEA DX,MSG5
		INT 21H 

		CMP CHOICE,"1"
		JE TYPE1

		CMP CHOICE,"2"
		JE TYPE2

		CMP CHOICE,"3"
		JE TYPE3

		CMP CHOICE,"4"
		JE TYPE4

		CMP CHOICE,"5"
		JE TYPE5

		TYPE1:
			MOV AH,09H
			LEA DX,TYPE1M
			INT 21H
			
			JMP EXIT

		TYPE2:
			MOV AH,09H
			LEA DX,TYPE2M
			INT 21H
			
			JMP EXIT

		TYPE3:
			MOV AH,09H
			LEA DX,TYPE3M
			INT 21H
	
			JMP EXIT

		TYPE4:
			MOV AH,09H
			LEA DX,TYPE4M
			INT 21H
	
			JMP EXIT

		TYPE5:
			MOV AH,09H
			LEA DX,TYPE5M
			INT 21H
		
			JMP EXIT
	
	EXIT:
		
		
		;DISPLAY NUMBER CONVERTED TO STRING.
		MOV DX , OFFSET OUTPUT
		MOV AH, 09H
		INT 21H 

		MOV AH,09H
		LEA DX,KG
		INT 21H 
		
		MOV AX,4C00H
		INT 21H

MAIN ENDP
END MAIN